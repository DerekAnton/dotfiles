# Lists names & descriptions for all available functions in bash_functions
function functions() { grep -B1 "function .*()" ~/.bash_functions | sed 's/{.*//g' | sed 's/function //g' | more; }

# Find file
function ff() { find . -type f -iname "$1"; }

# Find directory
function fd() { find . -type d -iname "$1"; }

# Change directory to a given users area
function theirs()   { cd /home/"$1"/git/RTSTF/ && pwd; }

# Assumes you are in ~user/git/RTSTF/ and takes filename path(s) to meld against in your area
function meldmine() { if [[ $# < 1 ]]; then echo "Usage: <Files to compare> (Assumes you are in ~user/git/RTSTF/)"; else for FILE in "$@"; do meld "$FILE" "$HOME/git/RTSTF/$FILE"; done; fi; }

# Assumes you are in ~/git/RTSTF/ takes 1.) username to compare against 2.) a single filename to compare
function meldtheirs() { if [[ $# != 2 ]]; then echo "Usage: <User to compare against> <File to compare> (Assumes you are in ~/git/RTSTF/)"; else meld $(pwd)/$2 $(pwd | sed "s|$USER|$1|")/$2; fi; }

# Assumes you are in ~/git/RTSTF/ takes name of a stash (Ex. stash@{0}) to meld against HEAD
function meldstash() { git stash show --name-only $* | xargs -I{} git difftool HEAD..$* '{}'; }

# Assumes you are in ~user/git/RTSTF/ and copies given file(s) there
function take() { if [[ $# < 1 ]]; then echo "Usage: <Space delimited file names to be copied to ~/git/RTSTF/ from ~user/git/RTSTF/>"; else for FILE in "$@"; do cp -rp "$FILE" "$HOME/git/RTSTF/$FILE"; echo "Copied $FILE to $HOME/git/RTSTF/$FILE"; done; fi; }

# Assumes you are in ~user/git/RTSTF/ and copies all modified files in their area to yours
function take-mods() { take $(git status --short | grep 'M \|MM ' | sed 's/  / /g' | sed 's/^ *//g' | cut -d ' ' -f2 | xargs); }

# Assumes you are in ~user/git/RTSTF/ and copies all files from their git status
function take-all() { take $(git status --short | sed 's/  / /g' | sed 's/^ *//g' | cut -d ' ' -f2 | xargs); }

# Quick C++ tool creation (copies from premade template files in ~/.template
function new-tool() { if [[ $# != 1 ]]; then echo "Usage: <Name of new tool>"; else cd ~/tools/ && mkdir $1 && cp .template/* $1/ && sed -i "s|REPLACE|$1|g" $1/Makefile && cd $1 && vim main.cpp; fi; }

# Opens all files that have been modified (and are new) in a git repo in vim tabs
function edit-all() { vim -p $(gits | cut -c 4- | sort | uniq | xargs); }

# Opens files that have been modified (ignores new files) in a git repo in vim tabs
function edit-mods() { vim -p $(gits | cut -c 4- | grep 'M \|MM ' | sed 's/  / /g' | cut -d ' ' -f2 | sort | uniq | xargs); }

# Greps for a pattern in the current directory and opens all files containing that pattern (explicit excludes ctag and cscope files)
function open-containing() { if [[ $# < 1 ]]; then echo "Usage: <Pattern to search> <Directory to search in (Optional)>"; else vim -p $(grep -IiR --exclude=*cscope* --exclude=cscope --exclude=tags --exclude=TAGS --exclude=*.orig $1 $2 | cut -d ':' -f1 | sort | uniq | xargs); fi; }

# Finds all files containing a pattern and opens them in vim tabs
function open-named() { vim -p $(find . -iname "$1"); }

# Cleans up .orig files generated by git
function remove-origs() { FILES=$(find . -iname *.orig | xargs);  if [[ $FILES == "" ]]; then echo "no files to remove"; else rm $FILES; echo "removed all orig files successfully"; fi; }

# Removes all untracked files from a git repo
function remove-untracked() { rm -f $(gits | grep "?" | sed 's/?? //g' | xargs); }

function clear-logsoutput() { rm -rf ~/RTSTF_master/{output,logs}/*; }

# Prints the current scenario a provided user's RTSTF_master is configured for (blank denotes your user)
function scenario()
{
    if   [[ $# == 0 ]]; then USER="${HOME}";
    elif [[ $# == 1 ]]; then USER=$(echo $HOME | sed s/"$(whoami)"/$1/g);
    else echo "Usage: <Username (optional)>"; return; fi

    ls -l "${USER}/RTSTF_master/config" | xargs | cut -d " " -f 11  | sed 's/^\/.*Scenarios\///g' | sed 's/\/.*//g'
}

# Determines which boost test suites to run based on the changes you have in your area
function relevant-tests()
{
    FILES="$(basename -a $(git status --short | grep -v '??' | cut -c 4- | sort | uniq))";
    if [[ $? != 0 ]]
    then
        echo "No changes to test"
        return;
    fi

    echo "Searching for relevant tests to run..."

    SUITES=""
    for FILE in $FILES;
    do
        # For each cpp or hpp
        echo "$FILE" | grep -q ".cpp\|.hpp";
        if [[ $? == 0 ]];
        then
           # Look for a file with the same basename that ends with the word 'Test'
           TEST_FILE=$(echo $(find "$HOME/git/RTSTF/" -iname "$(echo $FILE | sed 's/\.hpp//g' | sed 's/\.cpp//g')Test*"))

           # If there we've found a matching test file
           if [[ "${TEST_FILE}" != "" ]];
           then
               # Save off the name of the boost test suite to be called later
               SUITES=$(echo "$SUITES" $(grep "BOOST_AUTO_TEST_SUITE(" "${TEST_FILE}" | sed 's/BOOST_AUTO_TEST_SUITE(//g' | sed 's/)//g'),)
           fi
        fi
    done;

    SUITES=$(echo "$SUITES" | sed "s/,*$//g")
    echo "Found the following tests:$SUITES"

    SUITES=$(echo "$SUITES" | sed 's/ //g')
    make test TEST="$SUITES"
}

# Renames any variable (or string value) in files you are currently modifying  (sed using @ to avoid common character conflicts)
refactor() { if [[ $# != 2 ]]; then echo "Usage: <string to find> <string to replace>"; else sed -i "s@$1@$2@g" $(gits | cut -c 4- | sort | uniq | xargs); fi;}

# Searches all wiki files for a given pattern (regex support)
search-wiki() { grep $1 $(ff *.md); }

# Returns the short git status in one line (all files)
gits-oneline() { echo $(git status --short | cut -c 4- | sort | uniq | xargs); }

# Returns the short git status in one line (only tracked files)
gits-oneline-tracked() { echo $(git status --short | grep -v "?" | cut -c 4- | sort | uniq | xargs); }

# Sets gnome-terminal title to a provided string
function set-title()   { PROMPT_COMMAND= ; echo -ne "\033]0;$*\007"; }

# Resets gnome-terminal title to normal title
function reset-title() { echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/~}\007"; }

# List all C++ file names
function flist()  { find . -iname '*.cpp' -o -iname '*.cc' -o -iname '*.c' -o -iname '*.hpp' -o -iname '*.hh' -o -iname '*.h'; }

# List all makefiles
function mlist()  { find . -iname 'makefile'; }

# Builds CTags for vim development
function mktags() { cd ~/git/RTSTF && flist > cscope.files && ctags -L cscope.files && cscope -bqv; }

# Melds against current HEAD against a provided stash (i.e. stash@{0})
function meld-stash() { git stash show --name-only $* | xargs -I{} git difftool HEAD..$* '{}'; }

# Creates a git bundle; assumes you are in a git repository where HEAD is the commit you want to bundle to. Takes 1.) Filename of output bundle 2.) SHA ID of oldest commit to start from (exclusive)
function create-bundle() { if [[ $# < 2 ]]; then echo "Usage: 1.) Filename of output bundle 2.) SHA ID of oldest commit to start from"; else git bundle create "$1" "$2"..HEAD --tags --branches; fi; }

# Encrypt AES256
function encrypt() { openssl enc -aes-256-cbc -salt -in $1 -out $(pwd)/encrypted; }

# Decrypt AES256
function decrypt { openssl enc -aes-256-cbc -d -in $1 -out decrypted.out; }

# Pull from the many pnt repos
function pull-pnt() { for REPO in ~/git/pnt/*/; do basename $REPO; git -C $REPO pull; done; }

# Takes in the executable to extract a core file from RHEL core repository
get-core-for() { EXECUTABLE=$1; cd ~/RTSTF_master/bin/; sudo coredumpctl -o ~/corefile.dump dump ${EXECUTABLE}; gdb -tui ~/RTSTF_master/bin/${EXECUTABLE} ~/corefile.dump; rm -f ~/corefile.dump; }

# Run make test on a given directory (recursive find all test suites)
make-test-dir() { if [[ $# != 1 ]]; then echo "Usage: <path to directory you want to run RTSTF tests>"; else cd ~/git/RTSTF; make test TEST=$(grep -R 'BOOST_AUTO_TEST_SUITE(' $1 | sed 's/.*BOOST_AUTO_TEST_SUITE(\(.*\))/\1/g' | xargs | tr -s ' ' ','); fi; }
